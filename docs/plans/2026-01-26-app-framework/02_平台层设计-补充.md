# å¹³å°å±‚è®¾è®¡ - æŠ€æœ¯è¡¥å……

> ç‰ˆæœ¬ï¼šv1.0
> æ—¥æœŸï¼š2026-01-27
> è¯´æ˜ï¼šæœ¬æ–‡æ¡£è¡¥å…… `02_å¹³å°å±‚è®¾è®¡.md` ä¸­çš„æŠ€æœ¯å®ç°ç»†èŠ‚

## 1. UI æ’ä»¶çƒ­é‡è½½æœºåˆ¶

### 1.1 çƒ­é‡è½½æ¶æ„

```typescript
// packages/shared/src/platform/hot-reload.ts

interface HotReloadConfig {
  enabled: boolean
  watchPaths: string[]
  debounceMs: number
}

class PluginHotReloader {
  private watchers: Map<string, FSWatcher> = new Map()
  private debounceTimers: Map<string, NodeJS.Timeout> = new Map()

  constructor(
    private registry: PluginRegistry,
    private config: HotReloadConfig
  ) {}

  async watchPlugin(pluginId: string) {
    const plugin = this.registry.get(pluginId)
    if (!plugin) return

    const pluginPath = this.getPluginPath(pluginId)

    // ç›‘å¬æ–‡ä»¶å˜åŒ–
    const watcher = fs.watch(
      pluginPath,
      { recursive: true },
      (eventType, filename) => {
        this.handleFileChange(pluginId, filename)
      }
    )

    this.watchers.set(pluginId, watcher)
  }

  private handleFileChange(pluginId: string, filename: string) {
    // æ¸…é™¤ä¹‹å‰çš„é˜²æŠ–å®šæ—¶å™¨
    const existingTimer = this.debounceTimers.get(pluginId)
    if (existingTimer) {
      clearTimeout(existingTimer)
    }

    // è®¾ç½®æ–°çš„é˜²æŠ–å®šæ—¶å™¨
    const timer = setTimeout(() => {
      this.reloadPlugin(pluginId)
    }, this.config.debounceMs)

    this.debounceTimers.set(pluginId, timer)
  }

  private async reloadPlugin(pluginId: string) {
    console.log(`[HotReload] Reloading plugin: ${pluginId}`)

    // 1. ä¿å­˜æ’ä»¶çŠ¶æ€
    const plugin = this.registry.get(pluginId)
    const state = await plugin.getState?.()

    // 2. å¸è½½æ—§ç‰ˆæœ¬
    await this.registry.unregister(pluginId)

    // 3. æ¸…é™¤æ¨¡å—ç¼“å­˜
    this.clearModuleCache(pluginId)

    // 4. é‡æ–°åŠ è½½æ’ä»¶
    const newPlugin = await this.registry.load(this.getPluginPath(pluginId))

    // 5. æ¢å¤çŠ¶æ€
    if (state && newPlugin.setState) {
      await newPlugin.setState(state)
    }

    // 6. é€šçŸ¥ UI æ›´æ–°
    this.notifyUIUpdate(pluginId)
  }

  private clearModuleCache(pluginId: string) {
    const pluginPath = this.getPluginPath(pluginId)

    // åˆ é™¤ require.cache ä¸­çš„æ¨¡å—
    Object.keys(require.cache).forEach(key => {
      if (key.startsWith(pluginPath)) {
        delete require.cache[key]
      }
    })
  }

  private notifyUIUpdate(pluginId: string) {
    // é€šè¿‡äº‹ä»¶æ€»çº¿é€šçŸ¥å‰ç«¯
    eventBus.emit('plugin:reloaded', { pluginId })
  }
}
```

### 1.2 å‰ç«¯çƒ­é‡è½½è®¢é˜…

```typescript
// apps/electron/src/renderer/hooks/usePluginHotReload.ts

export function usePluginHotReload(pluginId: string) {
  const [version, setVersion] = useState(0)

  useEffect(() => {
    const handleReload = (event: { pluginId: string }) => {
      if (event.pluginId === pluginId) {
        // å¼ºåˆ¶é‡æ–°æ¸²æŸ“ç»„ä»¶
        setVersion(v => v + 1)
      }
    }

    eventBus.on('plugin:reloaded', handleReload)

    return () => {
      eventBus.off('plugin:reloaded', handleReload)
    }
  }, [pluginId])

  return version
}

// åœ¨æ’ä»¶ç»„ä»¶ä¸­ä½¿ç”¨
function MyPluginComponent() {
  const reloadKey = usePluginHotReload('ui.my-plugin')

  return (
    <div key={reloadKey}>
      {/* ç»„ä»¶å†…å®¹ */}
    </div>
  )
}
```

---

## 2. æ’ä»¶é—´é€šä¿¡åè®®

### 2.1 äº‹ä»¶æ€»çº¿

```typescript
// packages/shared/src/platform/event-bus.ts

interface EventPayload {
  source: string       // å‘é€è€…æ’ä»¶ ID
  target?: string      // ç›®æ ‡æ’ä»¶ ID (å¯é€‰ï¼Œä¸æŒ‡å®šåˆ™å¹¿æ’­)
  type: string         // äº‹ä»¶ç±»å‹
  data: any            // äº‹ä»¶æ•°æ®
  timestamp: number
}

class PluginEventBus {
  private listeners: Map<string, Set<EventListener>> = new Map()
  private messageQueue: EventPayload[] = []
  private processing = false

  // å‘é€äº‹ä»¶
  emit(event: Omit<EventPayload, 'timestamp'>) {
    const payload: EventPayload = {
      ...event,
      timestamp: Date.now()
    }

    // æ·»åŠ åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    this.messageQueue.push(payload)

    // å¼‚æ­¥å¤„ç†
    this.processQueue()
  }

  // è®¢é˜…äº‹ä»¶
  on(eventType: string, listener: EventListener) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, new Set())
    }
    this.listeners.get(eventType)!.add(listener)
  }

  // å–æ¶ˆè®¢é˜…
  off(eventType: string, listener: EventListener) {
    const listeners = this.listeners.get(eventType)
    if (listeners) {
      listeners.delete(listener)
    }
  }

  private async processQueue() {
    if (this.processing) return

    this.processing = true

    while (this.messageQueue.length > 0) {
      const event = this.messageQueue.shift()!
      await this.deliverEvent(event)
    }

    this.processing = false
  }

  private async deliverEvent(event: EventPayload) {
    const listeners = this.listeners.get(event.type)

    if (!listeners || listeners.size === 0) {
      console.warn(`No listeners for event: ${event.type}`)
      return
    }

    // å¹¶è¡Œé€šçŸ¥æ‰€æœ‰ç›‘å¬è€…
    await Promise.all(
      Array.from(listeners).map(listener =>
        this.safeInvoke(listener, event)
      )
    )
  }

  private async safeInvoke(listener: EventListener, event: EventPayload) {
    try {
      await listener(event)
    } catch (error) {
      console.error(`Error in event listener:`, error)
    }
  }
}

export const eventBus = new PluginEventBus()
```

### 2.2 RPC è°ƒç”¨

```typescript
// packages/shared/src/platform/rpc.ts

interface RPCRequest {
  id: string
  method: string
  params: any[]
  timeout?: number
}

interface RPCResponse {
  id: string
  result?: any
  error?: string
}

class PluginRPC {
  private pendingCalls: Map<string, {
    resolve: (value: any) => void
    reject: (error: Error) => void
    timer: NodeJS.Timeout
  }> = new Map()

  // è°ƒç”¨å…¶ä»–æ’ä»¶çš„æ–¹æ³•
  async call(
    targetPluginId: string,
    method: string,
    params: any[] = [],
    timeout = 5000
  ): Promise<any> {
    const requestId = generateId()

    const request: RPCRequest = {
      id: requestId,
      method,
      params,
      timeout
    }

    return new Promise((resolve, reject) => {
      // è®¾ç½®è¶…æ—¶
      const timer = setTimeout(() => {
        this.pendingCalls.delete(requestId)
        reject(new Error(`RPC timeout: ${targetPluginId}.${method}`))
      }, timeout)

      this.pendingCalls.set(requestId, { resolve, reject, timer })

      // å‘é€ RPC è¯·æ±‚
      eventBus.emit({
        source: 'system',
        target: targetPluginId,
        type: 'rpc:request',
        data: request
      })
    })
  }

  // æ³¨å†Œ RPC å¤„ç†å™¨
  registerHandler(pluginId: string, handlers: Record<string, Function>) {
    eventBus.on('rpc:request', async (event: EventPayload) => {
      if (event.target !== pluginId) return

      const request = event.data as RPCRequest
      const handler = handlers[request.method]

      if (!handler) {
        this.sendResponse({
          id: request.id,
          error: `Method not found: ${request.method}`
        }, event.source)
        return
      }

      try {
        const result = await handler(...request.params)
        this.sendResponse({ id: request.id, result }, event.source)
      } catch (error) {
        this.sendResponse({
          id: request.id,
          error: error.message
        }, event.source)
      }
    })
  }

  private sendResponse(response: RPCResponse, targetPluginId: string) {
    eventBus.emit({
      source: 'system',
      target: targetPluginId,
      type: 'rpc:response',
      data: response
    })

    // å¤„ç†å“åº”
    eventBus.on('rpc:response', (event: EventPayload) => {
      const response = event.data as RPCResponse
      const pending = this.pendingCalls.get(response.id)

      if (pending) {
        clearTimeout(pending.timer)
        this.pendingCalls.delete(response.id)

        if (response.error) {
          pending.reject(new Error(response.error))
        } else {
          pending.resolve(response.result)
        }
      }
    })
  }
}

export const pluginRPC = new PluginRPC()
```

### 2.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
// æ’ä»¶ A: æä¾›æœåŠ¡
export default defineUIPlugin({
  id: 'ui.data-provider',

  async onLoad(context) {
    // æ³¨å†Œ RPC æ–¹æ³•
    pluginRPC.registerHandler('ui.data-provider', {
      async getUserData(userId: string) {
        return await fetchUserData(userId)
      },

      async saveUserData(userId: string, data: any) {
        return await saveData(userId, data)
      }
    })
  }
})

// æ’ä»¶ B: è°ƒç”¨æœåŠ¡
export default defineUIPlugin({
  id: 'ui.user-profile',

  async onLoad(context) {
    // è°ƒç”¨å…¶ä»–æ’ä»¶çš„æ–¹æ³•
    const userData = await pluginRPC.call(
      'ui.data-provider',
      'getUserData',
      ['user-123']
    )

    console.log('User data:', userData)
  }
})
```

---

## 3. æ’ä»¶æ²™ç®±éš”ç¦»

### 3.1 æƒé™ç³»ç»Ÿ

```typescript
// packages/shared/src/platform/permissions.ts

interface PluginPermissions {
  filesystem?: {
    read?: string[]      // å…è®¸è¯»å–çš„è·¯å¾„
    write?: string[]     // å…è®¸å†™å…¥çš„è·¯å¾„
  }
  network?: {
    domains?: string[]   // å…è®¸è®¿é—®çš„åŸŸå
  }
  storage?: {
    quota?: number       // å­˜å‚¨é…é¢ (bytes)
  }
  apis?: string[]        // å…è®¸è°ƒç”¨çš„ç³»ç»Ÿ API
}

class PermissionManager {
  private permissions: Map<string, PluginPermissions> = new Map()

  // åŠ è½½æ’ä»¶æƒé™
  loadPermissions(pluginId: string, manifest: PluginManifest) {
    const declaredPermissions = manifest.permissions || {}
    this.permissions.set(pluginId, declaredPermissions)
  }

  // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæƒé™
  canAccessFile(pluginId: string, filePath: string, mode: 'read' | 'write'): boolean {
    const perms = this.permissions.get(pluginId)?.filesystem
    if (!perms) return false

    const allowedPaths = mode === 'read' ? perms.read : perms.write
    if (!allowedPaths) return false

    return allowedPaths.some(pattern =>
      minimatch(filePath, pattern)
    )
  }

  // æ£€æŸ¥ç½‘ç»œæƒé™
  canAccessDomain(pluginId: string, url: string): boolean {
    const perms = this.permissions.get(pluginId)?.network
    if (!perms?.domains) return false

    const hostname = new URL(url).hostname
    return perms.domains.some(domain =>
      hostname === domain || hostname.endsWith(`.${domain}`)
    )
  }

  // æ£€æŸ¥å­˜å‚¨é…é¢
  canUseStorage(pluginId: string, size: number): boolean {
    const perms = this.permissions.get(pluginId)?.storage
    if (!perms?.quota) return size <= 10 * 1024 * 1024 // é»˜è®¤ 10MB

    const currentUsage = this.getStorageUsage(pluginId)
    return currentUsage + size <= perms.quota
  }

  private getStorageUsage(pluginId: string): number {
    // è®¡ç®—æ’ä»¶å½“å‰å­˜å‚¨ä½¿ç”¨é‡
    const storageDir = path.join(PLUGIN_DATA_DIR, pluginId)
    return getDirSize(storageDir)
  }
}

export const permissionManager = new PermissionManager()
```

### 3.2 æ²™ç®±åŒ–çš„æ–‡ä»¶ç³»ç»Ÿè®¿é—®

```typescript
// packages/shared/src/platform/sandbox-fs.ts

class SandboxedFileSystem {
  constructor(
    private pluginId: string,
    private permissionManager: PermissionManager
  ) {}

  async readFile(filePath: string): Promise<string> {
    // æ£€æŸ¥æƒé™
    if (!this.permissionManager.canAccessFile(this.pluginId, filePath, 'read')) {
      throw new Error(`Permission denied: Cannot read ${filePath}`)
    }

    return await fs.readFile(filePath, 'utf-8')
  }

  async writeFile(filePath: string, content: string): Promise<void> {
    // æ£€æŸ¥æƒé™
    if (!this.permissionManager.canAccessFile(this.pluginId, filePath, 'write')) {
      throw new Error(`Permission denied: Cannot write ${filePath}`)
    }

    // æ£€æŸ¥å­˜å‚¨é…é¢
    if (!this.permissionManager.canUseStorage(this.pluginId, content.length)) {
      throw new Error('Storage quota exceeded')
    }

    await fs.writeFile(filePath, content, 'utf-8')
  }
}
```

### 3.3 æ²™ç®±åŒ–çš„ç½‘ç»œè®¿é—®

```typescript
// packages/shared/src/platform/sandbox-network.ts

class SandboxedNetwork {
  constructor(
    private pluginId: string,
    private permissionManager: PermissionManager
  ) {}

  async fetch(url: string, options?: RequestInit): Promise<Response> {
    // æ£€æŸ¥æƒé™
    if (!this.permissionManager.canAccessDomain(this.pluginId, url)) {
      throw new Error(`Permission denied: Cannot access ${url}`)
    }

    // æ·»åŠ ç”¨æˆ·ä»£ç†
    const headers = new Headers(options?.headers)
    headers.set('User-Agent', `CreatorFlow-Plugin/${this.pluginId}`)

    return await fetch(url, {
      ...options,
      headers
    })
  }
}
```

### 3.4 æ’ä»¶ä¸Šä¸‹æ–‡éš”ç¦»

```typescript
// packages/shared/src/platform/plugin-context.ts

function createPluginContext(pluginId: string): PluginContext {
  return {
    // æ²™ç®±åŒ–çš„æ–‡ä»¶ç³»ç»Ÿ
    fs: new SandboxedFileSystem(pluginId, permissionManager),

    // æ²™ç®±åŒ–çš„ç½‘ç»œè®¿é—®
    network: new SandboxedNetwork(pluginId, permissionManager),

    // éš”ç¦»çš„å­˜å‚¨ç©ºé—´
    storage: {
      async get(key: string) {
        const filePath = path.join(PLUGIN_DATA_DIR, pluginId, `${key}.json`)
        const content = await fs.readFile(filePath, 'utf-8')
        return JSON.parse(content)
      },

      async set(key: string, value: any) {
        const filePath = path.join(PLUGIN_DATA_DIR, pluginId, `${key}.json`)
        await fs.writeFile(filePath, JSON.stringify(value), 'utf-8')
      }
    },

    // äº‹ä»¶æ€»çº¿ (å·²è¿‡æ»¤)
    events: {
      on: (event, handler) => eventBus.on(event, handler),
      emit: (event, data) => eventBus.emit({ source: pluginId, type: event, data })
    },

    // æ—¥å¿— (å¸¦æ’ä»¶æ ‡è¯†)
    logger: {
      info: (...args) => console.log(`[${pluginId}]`, ...args),
      warn: (...args) => console.warn(`[${pluginId}]`, ...args),
      error: (...args) => console.error(`[${pluginId}]`, ...args)
    }
  }
}
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 æ’ä»¶æ‡’åŠ è½½

```typescript
// packages/shared/src/platform/lazy-loader.ts

class PluginLazyLoader {
  private loadedPlugins: Set<string> = new Set()
  private loadingPromises: Map<string, Promise<Plugin>> = new Map()

  async loadWhenNeeded(pluginId: string): Promise<Plugin> {
    // å¦‚æœå·²åŠ è½½ï¼Œç›´æ¥è¿”å›
    if (this.loadedPlugins.has(pluginId)) {
      return registry.get(pluginId)!
    }

    // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œè¿”å›ç›¸åŒçš„ Promise
    if (this.loadingPromises.has(pluginId)) {
      return this.loadingPromises.get(pluginId)!
    }

    // å¼€å§‹åŠ è½½
    const promise = this.doLoad(pluginId)
    this.loadingPromises.set(pluginId, promise)

    try {
      const plugin = await promise
      this.loadedPlugins.add(pluginId)
      return plugin
    } finally {
      this.loadingPromises.delete(pluginId)
    }
  }

  private async doLoad(pluginId: string): Promise<Plugin> {
    const pluginPath = getPluginPath(pluginId)
    return await pluginLoader.load(pluginPath)
  }
}
```

### 4.2 æ’ä»¶ç¼“å­˜

```typescript
// packages/shared/src/platform/plugin-cache.ts

interface CacheEntry {
  plugin: Plugin
  loadedAt: number
  lastAccess: number
}

class PluginCache {
  private cache: Map<string, CacheEntry> = new Map()
  private maxSize = 50  // æœ€å¤šç¼“å­˜ 50 ä¸ªæ’ä»¶
  private ttl = 30 * 60 * 1000  // 30 åˆ†é’Ÿ

  get(pluginId: string): Plugin | undefined {
    const entry = this.cache.get(pluginId)

    if (!entry) return undefined

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - entry.loadedAt > this.ttl) {
      this.cache.delete(pluginId)
      return undefined
    }

    // æ›´æ–°è®¿é—®æ—¶é—´
    entry.lastAccess = Date.now()
    return entry.plugin
  }

  set(pluginId: string, plugin: Plugin) {
    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œç§»é™¤æœ€ä¹…æœªè®¿é—®çš„
    if (this.cache.size >= this.maxSize) {
      this.evictLRU()
    }

    this.cache.set(pluginId, {
      plugin,
      loadedAt: Date.now(),
      lastAccess: Date.now()
    })
  }

  private evictLRU() {
    let oldest: [string, CacheEntry] | null = null

    for (const entry of this.cache.entries()) {
      if (!oldest || entry[1].lastAccess < oldest[1].lastAccess) {
        oldest = entry
      }
    }

    if (oldest) {
      this.cache.delete(oldest[0])
    }
  }
}
```

---

## 5. å®‰å…¨æ€§

### 5.1 ä»£ç ç­¾åéªŒè¯

```typescript
// packages/shared/src/platform/signature.ts

import crypto from 'crypto'

class PluginSignatureVerifier {
  private trustedPublicKeys: Map<string, string> = new Map()

  // åŠ è½½å—ä¿¡ä»»çš„å…¬é’¥
  loadTrustedKeys() {
    // å®˜æ–¹æ’ä»¶å…¬é’¥
    this.trustedPublicKeys.set('official', OFFICIAL_PUBLIC_KEY)

    // è®¤è¯å¼€å‘è€…å…¬é’¥ (ä»æœåŠ¡å™¨åŠ è½½)
    // ...
  }

  // éªŒè¯æ’ä»¶ç­¾å
  async verifyPlugin(pluginPath: string): Promise<boolean> {
    // è¯»å–ç­¾åæ–‡ä»¶
    const signaturePath = path.join(pluginPath, 'signature.json')
    const signature = JSON.parse(await fs.readFile(signaturePath, 'utf-8'))

    // è®¡ç®—æ’ä»¶å†…å®¹å“ˆå¸Œ
    const contentHash = await this.calculatePluginHash(pluginPath)

    // éªŒè¯ç­¾å
    const publicKey = this.trustedPublicKeys.get(signature.keyId)
    if (!publicKey) {
      throw new Error(`Unknown key ID: ${signature.keyId}`)
    }

    const verify = crypto.createVerify('SHA256')
    verify.update(contentHash)
    verify.end()

    return verify.verify(publicKey, signature.signature, 'base64')
  }

  private async calculatePluginHash(pluginPath: string): Promise<string> {
    const files = await glob('**/*', { cwd: pluginPath, ignore: ['signature.json'] })
    const hash = crypto.createHash('sha256')

    for (const file of files.sort()) {
      const content = await fs.readFile(path.join(pluginPath, file))
      hash.update(content)
    }

    return hash.digest('hex')
  }
}
```

### 5.2 è¿è¡Œæ—¶ç›‘æ§

```typescript
// packages/shared/src/platform/monitor.ts

class PluginMonitor {
  private metrics: Map<string, PluginMetrics> = new Map()

  recordAPICall(pluginId: string, api: string) {
    const metrics = this.getMetrics(pluginId)
    metrics.apiCalls[api] = (metrics.apiCalls[api] || 0) + 1

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if (metrics.apiCalls[api] > API_RATE_LIMIT) {
      this.throttlePlugin(pluginId)
    }
  }

  recordError(pluginId: string, error: Error) {
    const metrics = this.getMetrics(pluginId)
    metrics.errors.push({
      message: error.message,
      stack: error.stack,
      timestamp: Date.now()
    })

    // å¦‚æœé”™è¯¯è¿‡å¤šï¼Œç¦ç”¨æ’ä»¶
    if (metrics.errors.length > 10) {
      this.disablePlugin(pluginId)
    }
  }

  private getMetrics(pluginId: string): PluginMetrics {
    if (!this.metrics.has(pluginId)) {
      this.metrics.set(pluginId, {
        apiCalls: {},
        errors: [],
        memoryUsage: 0
      })
    }
    return this.metrics.get(pluginId)!
  }

  private throttlePlugin(pluginId: string) {
    console.warn(`[Monitor] Throttling plugin: ${pluginId}`)
    // å®ç°é™æµé€»è¾‘
  }

  private disablePlugin(pluginId: string) {
    console.error(`[Monitor] Disabling plugin due to errors: ${pluginId}`)
    registry.unregister(pluginId)
  }
}
```

---

## 6. å®æ–½å»ºè®®

### Phase 1 ä¼˜å…ˆçº§ (æ ¸å¿ƒåŠŸèƒ½)
- âœ… æ’ä»¶åŸºç¡€åŠ è½½æœºåˆ¶
- âœ… æƒé™ç³»ç»Ÿ
- âœ… æ’ä»¶ä¸Šä¸‹æ–‡éš”ç¦»

### Phase 2 ä¼˜å…ˆçº§ (å¼€å‘ä½“éªŒ)
- âš ï¸ çƒ­é‡è½½æœºåˆ¶
- âš ï¸ æ’ä»¶é—´é€šä¿¡ (äº‹ä»¶æ€»çº¿)

### Phase 3 ä¼˜å…ˆçº§ (æ€§èƒ½å’Œå®‰å…¨)
- ğŸ”µ æ‡’åŠ è½½å’Œç¼“å­˜
- ğŸ”µ ä»£ç ç­¾åéªŒè¯
- ğŸ”µ è¿è¡Œæ—¶ç›‘æ§

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¡¥å……äº†å¹³å°å±‚æ’ä»¶ç³»ç»Ÿçš„å…³é”®æŠ€æœ¯ç»†èŠ‚ï¼š

1. **çƒ­é‡è½½**: æ–‡ä»¶ç›‘å¬ + æ¨¡å—ç¼“å­˜æ¸…é™¤ + çŠ¶æ€æ¢å¤
2. **æ’ä»¶é€šä¿¡**: äº‹ä»¶æ€»çº¿ + RPC è°ƒç”¨
3. **æ²™ç®±éš”ç¦»**: æƒé™ç³»ç»Ÿ + API åŒ…è£…
4. **æ€§èƒ½ä¼˜åŒ–**: æ‡’åŠ è½½ + LRU ç¼“å­˜
5. **å®‰å…¨æ€§**: ä»£ç ç­¾å + è¿è¡Œæ—¶ç›‘æ§

è¿™äº›æœºåˆ¶ç¡®ä¿æ’ä»¶ç³»ç»Ÿçš„**å¯é æ€§ã€å®‰å…¨æ€§å’Œå¼€å‘æ•ˆç‡**ã€‚
