# 能力层设计

> 版本：v1.0
> 日期：2026-01-26

## 概述

能力层提供独立的 Skills 和 Workflows，可以单独发布到技能市场，支持运行时动态安装和热更新。

**重要说明**：CreatorFlow 的 Skills 完全兼容 **Claude Agent Skill** 格式，可以直接使用 Claude 官方或社区开源的 skills，无需任何修改。

## Skills（技能）

### Claude Agent Skill 兼容性

CreatorFlow 完全支持 Claude Agent Skill 标准格式，这意味着：

1. **直接使用官方 Skills**：可以直接导入和使用 Claude 官方提供的 skills
2. **兼容社区 Skills**：支持使用社区开源的 Claude Agent Skills
3. **无需修改**：现有的 Claude Agent Skills 可以直接在 CreatorFlow 中运行
4. **生态共享**：可以将 CreatorFlow 开发的 skills 分享给 Claude Agent 社区

### 定义格式

Skills 使用标准的 Claude Agent Skill YAML 格式定义：

```yaml
# skills/material-organize/skill.yaml
id: skill.material-organize
name: 素材整理
version: 1.0.0
author: CreatorFlow Team
description: 帮助整理和分类创作素材

# Skill 类型
type: conversational  # conversational | tool | workflow

# AI 模型配置
model: claude-sonnet-4.5
temperature: 0.7
maxTokens: 4000

# Prompt 定义
prompt: |
  你是一个专业的素材整理助手，帮助创作者整理和分类各种创作素材。

  你的职责：
  1. 分析素材内容（图片、文本、视频等）
  2. 提取关键信息和标签
  3. 建议分类和归档方式
  4. 识别素材之间的关联关系

  请以友好、专业的方式与用户交流。

# 系统 Prompt（可选）
systemPrompt: |
  你是 CreatorFlow 的素材整理助手。

# 工具能力（可选）
tools:
  - name: classify_image
    description: 对图片进行分类和标签提取
    parameters:
      type: object
      properties:
        imagePath:
          type: string
          description: 图片文件路径
      required: [imagePath]

  - name: extract_text
    description: 从图片中提取文字
    parameters:
      type: object
      properties:
        imagePath:
          type: string
          description: 图片文件路径
      required: [imagePath]

  - name: save_material
    description: 保存素材到素材库
    parameters:
      type: object
      properties:
        title:
          type: string
          description: 素材标题
        content:
          type: string
          description: 素材内容
        tags:
          type: array
          items:
            type: string
          description: 标签列表
        category:
          type: string
          description: 分类
      required: [title, content]

# 依赖的平台能力
dependencies:
  models:
    - model.material@^1.0.0
  integrations: []

# 配置选项
config:
  autoSave: true
  suggestTags: true
  maxSuggestions: 5

# 示例对话
examples:
  - user: "帮我整理这张图片"
    assistant: "好的，让我分析一下这张图片。[调用 classify_image]"

  - user: "这些素材应该怎么分类？"
    assistant: "根据内容分析，我建议按照以下方式分类..."

# 权限要求
permissions:
  - filesystem  # 访问文件系统
  - vision      # 图片分析能力
```

### Skill 类型

#### 1. Conversational Skill（对话式技能）

纯对话交互，不需要工具调用：

```yaml
id: skill.script-create
name: 脚本创作
type: conversational
model: claude-sonnet-4.5

prompt: |
  你是一个专业的脚本创作助手，帮助创作者撰写各种平台的内容脚本。

  你擅长：
  - 小红书图文脚本（标题、正文、标签）
  - 抖音短视频脚本（口播稿、分镜）
  - 公众号长文（结构、段落、配图建议）

  请根据用户的选题和素材，创作吸引人的内容。
```

#### 2. Tool Skill（工具式技能）

提供特定功能，通过工具调用执行：

```yaml
id: skill.seo-analyzer
name: SEO 分析
type: tool
model: claude-sonnet-4.5

tools:
  - name: analyze_keywords
    description: 分析关键词密度和相关性

  - name: check_readability
    description: 检查内容可读性

  - name: suggest_improvements
    description: 提供 SEO 优化建议
```

#### 3. Workflow Skill（流程式技能）

包含多个步骤的复杂流程：

```yaml
id: skill.content-review
name: 内容审核
type: workflow

steps:
  - name: check_sensitive_words
    description: 检查敏感词

  - name: check_grammar
    description: 检查语法错误

  - name: check_platform_rules
    description: 检查平台规则

  - name: generate_report
    description: 生成审核报告
```

### Skill 加载机制

```typescript
// Skill 加载器
class SkillLoader {
  async load(skillPath: string): Promise<Skill> {
    // 读取 skill.yaml
    const config = await this.readYaml(skillPath)

    // 验证配置
    this.validate(config)

    // 创建 Skill 实例
    const skill = new Skill(config)

    // 注册工具
    if (config.tools) {
      for (const tool of config.tools) {
        skill.registerTool(tool)
      }
    }

    // 检查依赖
    await this.checkDependencies(config.dependencies)

    return skill
  }

  private async checkDependencies(deps: Dependencies) {
    const registry = getPluginRegistry()

    // 检查数据模型依赖
    for (const modelDep of deps.models || []) {
      const [id, version] = modelDep.split('@')
      const model = registry.get(id)

      if (!model) {
        throw new Error(`Required model ${id} not found`)
      }

      if (!this.satisfiesVersion(model.version, version)) {
        throw new Error(`Model ${id} version mismatch`)
      }
    }

    // 检查集成依赖
    for (const integrationDep of deps.integrations || []) {
      const [id, version] = integrationDep.split('@')
      const integration = registry.get(id)

      if (!integration) {
        throw new Error(`Required integration ${id} not found`)
      }
    }
  }
}
```

### Skill 执行

```typescript
// Skill 实例
class Skill {
  constructor(private config: SkillConfig) {}

  async execute(input: string, context: SkillContext): Promise<SkillResult> {
    // 构建消息
    const messages = [
      {
        role: 'system',
        content: this.config.systemPrompt || this.config.prompt
      },
      {
        role: 'user',
        content: input
      }
    ]

    // 调用 AI 模型
    const response = await this.callModel(messages, context)

    // 处理工具调用
    if (response.toolCalls) {
      const toolResults = await this.executeTools(response.toolCalls, context)

      // 继续对话
      messages.push({
        role: 'assistant',
        content: response.content,
        toolCalls: response.toolCalls
      })

      messages.push({
        role: 'tool',
        content: JSON.stringify(toolResults)
      })

      return this.execute(messages, context)
    }

    return {
      content: response.content,
      usage: response.usage
    }
  }

  private async executeTools(toolCalls: ToolCall[], context: SkillContext) {
    const results = []

    for (const call of toolCalls) {
      const tool = this.tools.get(call.name)
      if (!tool) {
        throw new Error(`Tool ${call.name} not found`)
      }

      const result = await tool.execute(call.arguments, context)
      results.push(result)
    }

    return results
  }
}
```

### 工具实现

```typescript
// 工具注册
class ToolRegistry {
  private tools = new Map<string, Tool>()

  register(name: string, tool: Tool) {
    this.tools.set(name, tool)
  }

  get(name: string): Tool | undefined {
    return this.tools.get(name)
  }
}

// 工具接口
interface Tool {
  name: string
  description: string
  parameters: ToolParameters
  execute(args: any, context: SkillContext): Promise<any>
}

// 示例：保存素材工具
const saveMaterialTool: Tool = {
  name: 'save_material',
  description: '保存素材到素材库',
  parameters: {
    type: 'object',
    properties: {
      title: { type: 'string' },
      content: { type: 'string' },
      tags: { type: 'array', items: { type: 'string' } },
      category: { type: 'string' }
    },
    required: ['title', 'content']
  },

  async execute(args, context) {
    // 获取数据模型
    const materialModel = context.registry.get('model.material')

    // 保存素材
    const material = await materialModel.create({
      title: args.title,
      content: args.content,
      tags: args.tags || [],
      category: args.category || 'uncategorized',
      createdAt: new Date()
    })

    return {
      success: true,
      materialId: material.id,
      message: `素材"${args.title}"已保存`
    }
  }
}
```

## Workflows（工作流）

### 定义格式

Workflows 使用 YAML 格式定义流程步骤：

```yaml
# workflows/topic-to-publish/workflow.yaml
id: workflow.topic-to-publish
name: 选题到发布流程
version: 1.0.0
author: CreatorFlow Team
description: 从选题研究到内容发布的完整工作流

# 流程步骤
steps:
  - id: topic-research
    name: 选题研究
    type: skill
    skill: skill.topic-research
    description: 研究选题，分析热点和用户需求
    config:
      autoSave: true
    outputs:
      - topicBrief
      - keywords
      - targetAudience

  - id: material-collect
    name: 素材收集
    type: skill
    skill: skill.material-organize
    description: 收集和整理相关素材
    dependsOn: [topic-research]
    inputs:
      keywords: "{{topic-research.keywords}}"
    outputs:
      - materials

  - id: script-create
    name: 脚本创作
    type: skill
    skill: skill.script-create
    description: 根据选题和素材创作脚本
    dependsOn: [topic-research, material-collect]
    inputs:
      topic: "{{topic-research.topicBrief}}"
      materials: "{{material-collect.materials}}"
    outputs:
      - script

  - id: content-review
    name: 内容审核
    type: human-review
    description: 人工审核内容质量
    dependsOn: [script-create]
    inputs:
      script: "{{script-create.script}}"
    config:
      reviewers: ["user"]
      approvalRequired: true
    outputs:
      - approved
      - feedback

  - id: content-optimize
    name: 内容优化
    type: skill
    skill: skill.content-optimizer
    description: 根据审核反馈优化内容
    dependsOn: [content-review]
    condition: "{{content-review.approved}} === false"
    inputs:
      script: "{{script-create.script}}"
      feedback: "{{content-review.feedback}}"
    outputs:
      - optimizedScript

  - id: platform-adapt
    name: 平台适配
    type: skill
    skill: skill.platform-adapter
    description: 将内容适配到不同平台
    dependsOn: [content-review]
    condition: "{{content-review.approved}} === true"
    inputs:
      script: "{{script-create.script}}"
      platforms: ["xiaohongshu", "douyin", "wechat"]
    outputs:
      - adaptedContent

  - id: schedule-publish
    name: 定时发布
    type: skill
    skill: skill.multi-platform-publish
    description: 发布到各个平台
    dependsOn: [platform-adapt]
    inputs:
      content: "{{platform-adapt.adaptedContent}}"
    config:
      scheduleTime: "auto"  # 自动选择最佳发布时间
    outputs:
      - publishResults

# 流程配置
config:
  # 是否自动进入下一步
  autoAdvance: false

  # 是否允许跳过步骤
  allowSkip: true

  # 超时设置（分钟）
  timeout:
    topic-research: 30
    material-collect: 60
    script-create: 60
    content-review: null  # 无超时限制
    platform-adapt: 30
    schedule-publish: 10

  # 错误处理
  errorHandling:
    retry: true
    maxRetries: 3
    onError: "pause"  # pause | skip | abort

  # 通知设置
  notifications:
    onStepComplete: true
    onWorkflowComplete: true
    onError: true

# 权限要求
permissions:
  - filesystem
  - network

# 依赖
dependencies:
  skills:
    - skill.topic-research@^1.0.0
    - skill.material-organize@^1.0.0
    - skill.script-create@^1.0.0
    - skill.content-optimizer@^1.0.0
    - skill.platform-adapter@^1.0.0
    - skill.multi-platform-publish@^1.0.0
```

### 步骤类型

#### 1. Skill 步骤

调用 Skill 执行任务：

```yaml
- id: script-create
  name: 脚本创作
  type: skill
  skill: skill.script-create
  inputs:
    topic: "{{topic-research.topicBrief}}"
  outputs:
    - script
```

#### 2. Human Review 步骤

需要人工审核：

```yaml
- id: content-review
  name: 内容审核
  type: human-review
  config:
    reviewers: ["user"]
    approvalRequired: true
  outputs:
    - approved
    - feedback
```

#### 3. Condition 步骤

条件判断：

```yaml
- id: check-quality
  name: 质量检查
  type: condition
  condition: "{{script-create.wordCount}} > 500"
  onTrue: next-step
  onFalse: rewrite-step
```

#### 4. Parallel 步骤

并行执行多个任务：

```yaml
- id: multi-platform-adapt
  name: 多平台适配
  type: parallel
  steps:
    - id: xiaohongshu-adapt
      skill: skill.xiaohongshu-adapter
    - id: douyin-adapt
      skill: skill.douyin-adapter
    - id: wechat-adapt
      skill: skill.wechat-adapter
```

### Workflow 执行引擎

```typescript
// Workflow 执行器
class WorkflowExecutor {
  private workflow: Workflow
  private context: WorkflowContext
  private state: WorkflowState

  constructor(workflow: Workflow) {
    this.workflow = workflow
    this.state = {
      currentStep: null,
      completedSteps: [],
      stepOutputs: new Map(),
      status: 'pending'
    }
  }

  async execute(initialInputs?: any): Promise<WorkflowResult> {
    this.state.status = 'running'
    this.context = this.createContext(initialInputs)

    try {
      // 按依赖顺序执行步骤
      const sortedSteps = this.topologicalSort(this.workflow.steps)

      for (const step of sortedSteps) {
        // 检查依赖是否完成
        if (!this.areDependenciesMet(step)) {
          throw new Error(`Dependencies not met for step ${step.id}`)
        }

        // 检查条件
        if (step.condition && !this.evaluateCondition(step.condition)) {
          continue
        }

        // 执行步骤
        this.state.currentStep = step.id
        const result = await this.executeStep(step)

        // 保存输出
        this.state.stepOutputs.set(step.id, result)
        this.state.completedSteps.push(step.id)

        // 触发事件
        this.context.events.emit('workflow.step-completed', {
          workflowId: this.workflow.id,
          stepId: step.id,
          result
        })

        // 检查是否自动进入下一步
        if (!this.workflow.config.autoAdvance) {
          await this.waitForUserConfirmation()
        }
      }

      this.state.status = 'completed'
      return {
        success: true,
        outputs: Object.fromEntries(this.state.stepOutputs)
      }
    } catch (error) {
      this.state.status = 'failed'
      return {
        success: false,
        error: error.message
      }
    }
  }

  private async executeStep(step: WorkflowStep): Promise<any> {
    switch (step.type) {
      case 'skill':
        return this.executeSkillStep(step)
      case 'human-review':
        return this.executeHumanReviewStep(step)
      case 'condition':
        return this.executeConditionStep(step)
      case 'parallel':
        return this.executeParallelStep(step)
      default:
        throw new Error(`Unknown step type: ${step.type}`)
    }
  }

  private async executeSkillStep(step: WorkflowStep): Promise<any> {
    // 获取 Skill
    const skill = await this.context.skillLoader.load(step.skill)

    // 准备输入
    const inputs = this.resolveInputs(step.inputs)

    // 执行 Skill
    const result = await skill.execute(inputs, this.context)

    return result
  }

  private async executeHumanReviewStep(step: WorkflowStep): Promise<any> {
    // 准备审核数据
    const inputs = this.resolveInputs(step.inputs)

    // 显示审核界面
    const review = await this.context.ui.showReviewDialog({
      title: step.name,
      description: step.description,
      data: inputs,
      reviewers: step.config.reviewers
    })

    return {
      approved: review.approved,
      feedback: review.feedback,
      reviewer: review.reviewer,
      reviewedAt: new Date()
    }
  }

  private resolveInputs(inputs: Record<string, string>): any {
    const resolved = {}

    for (const [key, value] of Object.entries(inputs)) {
      // 解析变量引用：{{step-id.output}}
      if (typeof value === 'string' && value.startsWith('{{')) {
        const path = value.slice(2, -2)
        const [stepId, outputKey] = path.split('.')
        const stepOutput = this.state.stepOutputs.get(stepId)
        resolved[key] = stepOutput?.[outputKey]
      } else {
        resolved[key] = value
      }
    }

    return resolved
  }

  private topologicalSort(steps: WorkflowStep[]): WorkflowStep[] {
    // 拓扑排序，确保依赖顺序
    const sorted: WorkflowStep[] = []
    const visited = new Set<string>()

    const visit = (step: WorkflowStep) => {
      if (visited.has(step.id)) return

      // 先访问依赖
      if (step.dependsOn) {
        for (const depId of step.dependsOn) {
          const depStep = steps.find(s => s.id === depId)
          if (depStep) visit(depStep)
        }
      }

      visited.add(step.id)
      sorted.push(step)
    }

    for (const step of steps) {
      visit(step)
    }

    return sorted
  }
}
```

### Workflow 可视化

```typescript
// Workflow 可视化组件
function WorkflowVisualization({ workflow, state }: Props) {
  return (
    <div className="workflow-visualization">
      {workflow.steps.map(step => (
        <WorkflowStepNode
          key={step.id}
          step={step}
          status={getStepStatus(step.id, state)}
          output={state.stepOutputs.get(step.id)}
        />
      ))}
    </div>
  )
}

function getStepStatus(stepId: string, state: WorkflowState): StepStatus {
  if (state.currentStep === stepId) return 'running'
  if (state.completedSteps.includes(stepId)) return 'completed'
  return 'pending'
}
```

## 导入 Claude Agent Skills

### 从官方或社区导入

CreatorFlow 支持直接导入现有的 Claude Agent Skills：

```bash
# 从 URL 导入
creatorflow import skill https://github.com/user/my-skill

# 从本地目录导入
creatorflow import skill ./path/to/skill

# 从 Claude Agent Skill 市场导入
creatorflow import skill claude://skill-name
```

### 导入流程

```typescript
async function importClaudeAgentSkill(source: string): Promise<Skill> {
  // 1. 下载或读取 skill 定义
  const skillYaml = await fetchSkill(source)

  // 2. 验证格式（完全兼容 Claude Agent Skill 格式）
  const skill = parseSkillYaml(skillYaml)
  validateClaudeAgentSkill(skill)

  // 3. 安装到 CreatorFlow
  const installedPath = path.join(SKILLS_DIR, skill.id)
  await fs.copy(skillYaml, path.join(installedPath, 'skill.yaml'))

  // 4. 注册 skill
  await registerSkill(skill)

  return skill
}
```

### 兼容性保证

CreatorFlow 确保与 Claude Agent Skill 的完全兼容：

1. **格式兼容**：支持所有 Claude Agent Skill 的标准字段
2. **工具兼容**：支持 Claude Agent Skill 的工具定义
3. **执行兼容**：使用相同的执行引擎和 API
4. **版本兼容**：支持 Claude Agent Skill 的版本管理

### 示例：导入官方 Skill

```bash
# 导入 Claude 官方的文件操作 skill
creatorflow import skill claude://file-operations

# 导入社区的数据分析 skill
creatorflow import skill https://github.com/community/data-analysis-skill

# 查看已安装的 skills
creatorflow skills list
```

## 技能市场集成

### 发布 Skill

```bash
# 打包 Skill（兼容 Claude Agent Skill 格式）
creatorflow pack skill material-organize

# 生成 material-organize-1.0.0.cfskill

# 发布到 CreatorFlow 技能市场
creatorflow publish material-organize-1.0.0.cfskill

# 同时发布到 Claude Agent Skill 社区（可选）
creatorflow publish material-organize-1.0.0.cfskill --claude-agent
```

### 安装 Skill

```bash
# 从 CreatorFlow 市场安装
creatorflow install skill material-organize

# 从 Claude Agent Skill 市场安装
creatorflow install skill claude://material-organize

# 从本地安装
creatorflow install ./material-organize-1.0.0.cfskill
```

### Skill 更新

```bash
# 检查更新
creatorflow check-updates

# 更新 Skill
creatorflow update skill material-organize

# 更新所有 skills
creatorflow update skills --all
```

### 跨平台共享

CreatorFlow 的 skills 可以与 Claude Agent 生态共享：

```bash
# 将 CreatorFlow skill 导出为 Claude Agent Skill 格式
creatorflow export skill material-organize --format claude-agent

# 发布到 Claude Agent Skill 社区
creatorflow publish material-organize --target claude-agent-community
```

## 下一步

阅读 [应用层设计](./04_应用层设计.md) 了解如何组合这些能力创建应用。
