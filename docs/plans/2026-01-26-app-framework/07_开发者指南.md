# 开发者指南

> 版本：v1.0
> 日期：2026-01-26

## 概述

本指南介绍如何开发 CreatorFlow 应用、插件、Skills 和 Workflows，以及如何发布到市场。

## 开发环境设置

### 安装 CLI 工具

```bash
# 全局安装 CreatorFlow CLI
npm install -g @creatorflow/cli

# 验证安装
creatorflow --version
```

### 安装 SDK

```bash
# 创建项目目录
mkdir my-app
cd my-app

# 初始化项目
npm init -y

# 安装 SDK
npm install @creatorflow/plugin-sdk
npm install @creatorflow/types
```

### 开发者账号

```bash
# 登录开发者账号
creatorflow login

# 查看账号信息
creatorflow whoami
```

## 开发应用

### 创建应用项目

```bash
# 创建新应用
creatorflow create app my-app

# 进入项目目录
cd my-app

# 项目结构
# my-app/
# ├── manifest.json
# ├── skills/
# ├── workflows/
# ├── assets/
# └── docs/
```

### 编写 Manifest

```json
{
  "id": "app.my-app",
  "name": "我的应用",
  "version": "1.0.0",
  "author": {
    "name": "Your Name",
    "email": "your@email.com"
  },
  "description": "应用描述",
  "license": "MIT",

  "pricing": {
    "type": "free"
  },

  "dependencies": {
    "platform": ">=1.0.0",
    "ui": [],
    "models": [],
    "integrations": []
  },

  "capabilities": {
    "skills": [],
    "workflows": []
  },

  "workspace": {
    "defaultDirectory": "~/MyApp",
    "directoryStructure": {
      "数据": {},
      "配置": {}
    },
    "defaultSettings": {
      "defaultModel": "claude-sonnet-4.5"
    }
  },

  "permissions": [
    "filesystem",
    "network"
  ],

  "marketplace": {
    "category": "productivity",
    "tags": ["工具", "效率"],
    "screenshots": []
  }
}
```

### 添加 Skills

```bash
# 创建 Skill
creatorflow create skill my-skill

# 编辑 skill.yaml
vim skills/my-skill/skill.yaml
```

```yaml
id: skill.my-skill
name: 我的技能
version: 1.0.0
type: conversational
model: claude-sonnet-4.5

prompt: |
  你是一个有用的助手...

tools:
  - name: do_something
    description: 执行某个操作
    parameters:
      type: object
      properties:
        param1:
          type: string
      required: [param1]

dependencies:
  models: []
  integrations: []
```

### 本地测试

```bash
# 启动开发模式
creatorflow dev

# 在另一个终端创建测试工作区
creatorflow workspace create --app ./my-app --test
```

## 开发平台插件

### 创建 UI 组件插件

```bash
# 创建 UI 插件
creatorflow create plugin ui my-component

# 项目结构
# my-component/
# ├── src/
# │   ├── index.ts
# │   ├── MyComponent.tsx
# │   └── settings.tsx
# ├── package.json
# ├── tsconfig.json
# └── manifest.json
```

### 实现插件

```typescript
// src/index.ts
import { defineUIPlugin } from '@creatorflow/plugin-sdk'
import MyComponent from './MyComponent'
import Settings from './settings'

export default defineUIPlugin({
  id: 'ui.my-component',
  name: '我的组件',
  version: '1.0.0',

  async onLoad(context) {
    // 注册路由
    context.router.addRoute({
      path: '/my-component',
      component: MyComponent
    })

    // 注册菜单
    context.menu.addItem({
      id: 'my-component',
      label: '我的组件',
      path: '/my-component'
    })
  },

  getComponent() {
    return MyComponent
  },

  getSettingsUI() {
    return Settings
  }
})
```

```typescript
// src/MyComponent.tsx
import React from 'react'
import { usePluginContext } from '@creatorflow/plugin-sdk'

export default function MyComponent() {
  const context = usePluginContext()

  return (
    <div>
      <h1>我的组件</h1>
      <p>这是一个自定义 UI 组件</p>
    </div>
  )
}
```

### 构建插件

```bash
# 安装依赖
npm install

# 构建
npm run build

# 输出到 dist/
```

### 创建数据模型插件

```typescript
// src/index.ts
import { defineModelPlugin } from '@creatorflow/plugin-sdk'
import { z } from 'zod'

const MyDataSchema = z.object({
  id: z.string(),
  name: z.string(),
  value: z.number(),
  createdAt: z.date()
})

type MyData = z.infer<typeof MyDataSchema>

export default defineModelPlugin<MyData>({
  id: 'model.my-data',
  name: '我的数据模型',
  version: '1.0.0',
  schema: MyDataSchema,

  async onLoad(context) {
    // 创建数据表
    await context.storage.createTable('my_data', {
      id: 'TEXT PRIMARY KEY',
      name: 'TEXT NOT NULL',
      value: 'INTEGER',
      createdAt: 'INTEGER NOT NULL'
    })
  },

  async create(data) {
    const item: MyData = {
      id: generateId(),
      ...data,
      createdAt: new Date()
    }

    const validated = this.schema.parse(item)
    await context.storage.insert('my_data', validated)

    return validated
  },

  async update(id, data) {
    const existing = await this.findById(id)
    if (!existing) {
      throw new Error(`Item ${id} not found`)
    }

    const updated = { ...existing, ...data }
    const validated = this.schema.parse(updated)

    await context.storage.update('my_data', { id }, validated)
    return validated
  },

  async delete(id) {
    await context.storage.delete('my_data', { id })
  },

  async query(filter = {}) {
    const results = await context.storage.query('my_data')
      .where(filter.where)
      .execute()

    return results.map(r => this.schema.parse(r))
  },

  async findById(id) {
    const result = await context.storage.findOne('my_data', { id })
    return result ? this.schema.parse(result) : null
  }
})
```

### 创建集成插件

```typescript
// src/index.ts
import { defineIntegrationPlugin } from '@creatorflow/plugin-sdk'
import { z } from 'zod'

const ConfigSchema = z.object({
  apiKey: z.string(),
  apiSecret: z.string()
})

export default defineIntegrationPlugin({
  id: 'integration.my-service',
  name: '我的服务集成',
  version: '1.0.0',
  configSchema: ConfigSchema,

  async onLoad(context) {
    this.config = await context.storage.get('my-service.config')
    this.client = new MyServiceClient(this.config)
  },

  async auth(credentials) {
    try {
      const response = await this.client.auth(credentials)

      await context.storage.set('my-service.token', {
        accessToken: response.access_token,
        expiresAt: new Date(Date.now() + response.expires_in * 1000)
      })

      return {
        success: true,
        accessToken: response.access_token
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  },

  async callApi(endpoint, data) {
    const token = await this.getValidToken()

    const response = await this.client.request(endpoint, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`
      },
      body: JSON.stringify(data)
    })

    return response.data
  },

  async getValidToken() {
    const token = await context.storage.get('my-service.token')

    if (new Date() >= token.expiresAt) {
      const refreshed = await this.refreshAuth()
      return refreshed.accessToken
    }

    return token.accessToken
  }
})
```

## 开发 Skills

### 对话式 Skill

```yaml
id: skill.my-conversational-skill
name: 我的对话技能
version: 1.0.0
type: conversational
model: claude-sonnet-4.5

prompt: |
  你是一个专业的助手，帮助用户完成特定任务。

  你的职责：
  1. 理解用户需求
  2. 提供专业建议
  3. 执行相关操作

examples:
  - user: "帮我做某事"
    assistant: "好的，我来帮你..."
```

### 工具式 Skill

```yaml
id: skill.my-tool-skill
name: 我的工具技能
version: 1.0.0
type: tool
model: claude-sonnet-4.5

tools:
  - name: process_data
    description: 处理数据
    parameters:
      type: object
      properties:
        data:
          type: string
          description: 要处理的数据
      required: [data]

  - name: save_result
    description: 保存结果
    parameters:
      type: object
      properties:
        result:
          type: string
      required: [result]

dependencies:
  models:
    - model.my-data@^1.0.0
```

### 实现工具函数

工具函数需要在平台层实现并注册：

```typescript
// 在插件或应用中注册工具
context.tools.register('process_data', {
  name: 'process_data',
  description: '处理数据',
  parameters: {
    type: 'object',
    properties: {
      data: { type: 'string' }
    },
    required: ['data']
  },
  async execute(args, context) {
    // 处理数据
    const processed = processData(args.data)

    return {
      success: true,
      result: processed
    }
  }
})
```

## 开发 Workflows

### 创建 Workflow

```yaml
id: workflow.my-workflow
name: 我的工作流
version: 1.0.0

steps:
  - id: step1
    name: 第一步
    type: skill
    skill: skill.my-skill
    outputs:
      - result1

  - id: step2
    name: 第二步
    type: skill
    skill: skill.another-skill
    dependsOn: [step1]
    inputs:
      data: "{{step1.result1}}"
    outputs:
      - result2

  - id: review
    name: 人工审核
    type: human-review
    dependsOn: [step2]
    inputs:
      data: "{{step2.result2}}"
    outputs:
      - approved

  - id: step3
    name: 第三步
    type: skill
    skill: skill.final-skill
    dependsOn: [review]
    condition: "{{review.approved}} === true"
    inputs:
      data: "{{step2.result2}}"

config:
  autoAdvance: false
  allowSkip: true
```

## 测试

### 单元测试

```typescript
// tests/plugin.test.ts
import { describe, it, expect } from 'vitest'
import plugin from '../src/index'

describe('MyPlugin', () => {
  it('should have correct id', () => {
    expect(plugin.id).toBe('ui.my-component')
  })

  it('should load successfully', async () => {
    const context = createMockContext()
    await plugin.onLoad(context)

    expect(context.router.routes).toHaveLength(1)
    expect(context.menu.items).toHaveLength(1)
  })
})
```

### 集成测试

```typescript
// tests/integration.test.ts
import { describe, it, expect } from 'vitest'
import { createTestWorkspace } from '@creatorflow/test-utils'

describe('App Integration', () => {
  it('should create workspace successfully', async () => {
    const workspace = await createTestWorkspace({
      appId: 'app.my-app'
    })

    expect(workspace).toBeDefined()
    expect(workspace.appId).toBe('app.my-app')
  })

  it('should execute skill successfully', async () => {
    const workspace = await createTestWorkspace({
      appId: 'app.my-app'
    })

    const skill = await workspace.loadSkill('skill.my-skill')
    const result = await skill.execute('test input')

    expect(result.content).toBeDefined()
  })
})
```

## 打包和发布

### 打包应用

```bash
# 打包应用
creatorflow pack

# 生成 my-app-1.0.0.cfapp
```

### 打包插件

```bash
# 构建插件
npm run build

# 打包插件
creatorflow pack plugin

# 生成 my-component-1.0.0.cfplugin
```

### 提交审核

```bash
# 提交到市场
creatorflow publish my-app-1.0.0.cfapp

# 查看提交状态
creatorflow status my-app
```

### 审核流程

1. **自动检查**：安全扫描、代码质量检查
2. **人工审核**：功能测试、内容审核
3. **审核结果**：通过或拒绝（附带原因）
4. **发布上架**：审核通过后自动上架

### 更新应用

```bash
# 更新版本号
vim manifest.json

# 打包新版本
creatorflow pack

# 提交更新
creatorflow publish my-app-1.1.0.cfapp --update
```

## 最佳实践

### 应用设计

1. **单一职责**：应用应该专注于解决特定问题
2. **模块化**：将功能拆分为独立的 Skills 和 Workflows
3. **可扩展**：支持插件应用扩展功能
4. **用户友好**：提供清晰的引导和文档

### 性能优化

1. **懒加载**：按需加载组件和资源
2. **缓存**：合理使用缓存减少重复计算
3. **异步操作**：使用异步操作避免阻塞
4. **资源清理**：及时清理不需要的资源

### 安全性

1. **输入验证**：验证所有用户输入
2. **权限最小化**：只申请必要的权限
3. **数据加密**：敏感数据加密存储
4. **安全通信**：使用 HTTPS 通信

### 用户体验

1. **加载状态**：显示加载进度和状态
2. **错误处理**：友好的错误提示
3. **快捷操作**：提供常用操作的快捷方式
4. **帮助文档**：提供详细的使用文档

## 调试技巧

### 日志输出

```typescript
// 使用 context.logger
context.logger.info('Info message')
context.logger.warn('Warning message')
context.logger.error('Error message')
context.logger.debug('Debug message')
```

### 开发者工具

```bash
# 查看日志
creatorflow logs

# 查看插件状态
creatorflow plugins list

# 重新加载插件
creatorflow plugins reload ui.my-component
```

### 断点调试

```typescript
// 在代码中设置断点
debugger

// 使用 VS Code 调试配置
{
  "type": "node",
  "request": "launch",
  "name": "Debug Plugin",
  "program": "${workspaceFolder}/src/index.ts",
  "outFiles": ["${workspaceFolder}/dist/**/*.js"]
}
```

## 发布清单

发布前检查：

- [ ] 版本号已更新
- [ ] Manifest 信息完整
- [ ] 所有依赖已声明
- [ ] 权限声明准确
- [ ] 截图和演示视频已准备
- [ ] 文档已完善
- [ ] 测试已通过
- [ ] 代码已签名
- [ ] 更新日志已编写

## 资源链接

- [API 文档](https://docs.creatorflow.com/api)
- [示例项目](https://github.com/creatorflow/examples)
- [开发者社区](https://community.creatorflow.com)
- [问题反馈](https://github.com/creatorflow/issues)

## 总结

本文档介绍了 CreatorFlow 应用框架的完整开发流程，包括：

1. 开发环境设置
2. 应用开发
3. 平台插件开发
4. Skills 和 Workflows 开发
5. 测试和调试
6. 打包和发布

遵循本指南和最佳实践，你可以开发出高质量的 CreatorFlow 应用并发布到市场。
