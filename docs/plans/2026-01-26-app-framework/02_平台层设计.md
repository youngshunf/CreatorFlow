# 平台层设计

> 版本：v1.0
> 日期：2026-01-26

## 概述

平台层提供可复用的底层能力，包括 UI 组件、数据模型和第三方集成。所有能力采用统一的插件接口，支持生命周期管理和动态加载。

## 插件系统架构

### 核心接口

所有平台能力都实现统一的插件接口：

```typescript
// 基础插件接口
interface Plugin {
  // 元信息
  id: string
  name: string
  version: string
  type: 'ui' | 'model' | 'integration'

  // 生命周期钩子
  onInstall?(context: PluginContext): Promise<void>
  onLoad?(context: PluginContext): Promise<void>
  onUnload?(context: PluginContext): Promise<void>
  onUninstall?(context: PluginContext): Promise<void>

  // 配置
  getSettingsUI?(): React.ComponentType
  getConfigSchema?(): z.ZodSchema
}

// 插件上下文
interface PluginContext {
  registry: PluginRegistry      // 插件注册表
  router: Router                // 路由管理器
  menu: MenuManager             // 菜单管理器
  storage: Storage              // 存储服务
  logger: Logger                // 日志服务
  events: EventEmitter          // 事件总线
}
```

### 插件注册表

全局插件注册表管理所有已加载的插件：

```typescript
class PluginRegistry {
  private plugins = new Map<string, Plugin>()
  private dependencies = new Map<string, Set<string>>()

  // 注册插件
  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.id)) {
      throw new Error(`Plugin ${plugin.id} already registered`)
    }
    this.plugins.set(plugin.id, plugin)
  }

  // 获取插件
  get<T extends Plugin>(id: string): T | undefined {
    return this.plugins.get(id) as T
  }

  // 按类型获取插件
  getByType(type: Plugin['type']): Plugin[] {
    return Array.from(this.plugins.values())
      .filter(p => p.type === type)
  }

  // 检查依赖
  checkDependencies(pluginId: string): boolean {
    const deps = this.dependencies.get(pluginId)
    if (!deps) return true

    for (const depId of deps) {
      if (!this.plugins.has(depId)) {
        return false
      }
    }
    return true
  }

  // 卸载插件
  async unregister(id: string): Promise<void> {
    const plugin = this.plugins.get(id)
    if (!plugin) return

    // 调用卸载钩子
    await plugin.onUnload?.(this.context)

    // 从注册表移除
    this.plugins.delete(id)
  }
}
```

## UI 组件插件

### 接口定义

```typescript
interface UIPlugin extends Plugin {
  type: 'ui'

  // 组件导出
  getComponent(): React.ComponentType

  // 路由配置（可选）
  getRoutes?(): RouteConfig[]

  // 菜单项配置（可选）
  getMenuItems?(): MenuItem[]

  // 工具栏配置（可选）
  getToolbarItems?(): ToolbarItem[]
}

// 路由配置
interface RouteConfig {
  path: string
  component: React.ComponentType
  exact?: boolean
  meta?: {
    title?: string
    icon?: string
    requireAuth?: boolean
  }
}

// 菜单项配置
interface MenuItem {
  id: string
  label: string
  icon?: string
  path?: string
  children?: MenuItem[]
  order?: number
}
```

### 实现示例：内容日历

```typescript
// plugins/content-calendar/src/index.ts
import { defineUIPlugin } from '@creatorflow/plugin-sdk'
import ContentCalendar from './ContentCalendar'
import CalendarSettings from './settings'

export default defineUIPlugin({
  id: 'ui.content-calendar',
  name: '内容日历',
  version: '1.0.0',

  async onLoad(context) {
    // 注册路由
    context.router.addRoute({
      path: '/calendar',
      component: ContentCalendar,
      meta: {
        title: '内容日历',
        icon: 'calendar',
        requireAuth: true
      }
    })

    // 注册菜单项
    context.menu.addItem({
      id: 'calendar',
      label: '内容日历',
      icon: 'calendar',
      path: '/calendar',
      order: 10
    })

    // 监听事件
    context.events.on('post.created', (post) => {
      context.logger.info('New post created:', post.id)
    })
  },

  async onUnload(context) {
    // 清理资源
    context.router.removeRoute('/calendar')
    context.menu.removeItem('calendar')
    context.events.off('post.created')
  },

  getComponent() {
    return ContentCalendar
  },

  getSettingsUI() {
    return CalendarSettings
  }
})
```

### UI 组件实现

```typescript
// plugins/content-calendar/src/ContentCalendar.tsx
import React, { useState, useEffect } from 'react'
import { usePluginContext } from '@creatorflow/plugin-sdk'
import { Calendar } from '@/components/ui/calendar'

export default function ContentCalendar() {
  const context = usePluginContext()
  const [posts, setPosts] = useState([])

  useEffect(() => {
    // 获取数据模型插件
    const postModel = context.registry.get('model.post')

    // 查询数据
    postModel.query({
      status: 'scheduled'
    }).then(setPosts)
  }, [])

  const handleDateClick = (date: Date) => {
    // 创建新作品
    context.events.emit('calendar.date-clicked', { date })
  }

  return (
    <div className="content-calendar">
      <Calendar
        posts={posts}
        onDateClick={handleDateClick}
      />
    </div>
  )
}
```

## 数据模型插件

### 接口定义

```typescript
interface ModelPlugin<T = any> extends Plugin {
  type: 'model'

  // 数据 schema
  schema: z.ZodSchema<T>

  // CRUD 操作
  create(data: Omit<T, 'id'>): Promise<T>
  update(id: string, data: Partial<T>): Promise<T>
  delete(id: string): Promise<void>
  query(filter?: QueryFilter<T>): Promise<T[]>
  findById(id: string): Promise<T | null>

  // 批量操作
  bulkCreate?(data: Omit<T, 'id'>[]): Promise<T[]>
  bulkUpdate?(updates: Array<{ id: string; data: Partial<T> }>): Promise<T[]>
  bulkDelete?(ids: string[]): Promise<void>

  // 数据迁移
  migrations?: Migration[]

  // 数据验证
  validate?(data: any): Promise<ValidationResult>

  // 数据转换
  transform?(data: any): T
}

// 查询过滤器
interface QueryFilter<T> {
  where?: Partial<T>
  orderBy?: { field: keyof T; direction: 'asc' | 'desc' }
  limit?: number
  offset?: number
}

// 数据迁移
interface Migration {
  version: number
  up: (db: Database) => Promise<void>
  down: (db: Database) => Promise<void>
}
```

### 实现示例：作品模型

```typescript
// plugins/post-model/src/index.ts
import { defineModelPlugin } from '@creatorflow/plugin-sdk'
import { z } from 'zod'

// 定义数据 schema
const PostSchema = z.object({
  id: z.string(),
  title: z.string(),
  content: z.string(),
  status: z.enum(['draft', 'scheduled', 'published']),
  platforms: z.array(z.string()),
  scheduledAt: z.date().optional(),
  publishedAt: z.date().optional(),
  createdAt: z.date(),
  updatedAt: z.date()
})

type Post = z.infer<typeof PostSchema>

export default defineModelPlugin<Post>({
  id: 'model.post',
  name: '作品模型',
  version: '1.0.0',
  schema: PostSchema,

  async onLoad(context) {
    // 初始化数据库表
    await context.storage.createTable('posts', {
      id: 'TEXT PRIMARY KEY',
      title: 'TEXT NOT NULL',
      content: 'TEXT',
      status: 'TEXT NOT NULL',
      platforms: 'TEXT',
      scheduledAt: 'INTEGER',
      publishedAt: 'INTEGER',
      createdAt: 'INTEGER NOT NULL',
      updatedAt: 'INTEGER NOT NULL'
    })
  },

  async create(data) {
    const post: Post = {
      id: generateId(),
      ...data,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    // 验证数据
    const validated = this.schema.parse(post)

    // 保存到数据库
    await context.storage.insert('posts', validated)

    // 触发事件
    context.events.emit('post.created', validated)

    return validated
  },

  async update(id, data) {
    const existing = await this.findById(id)
    if (!existing) {
      throw new Error(`Post ${id} not found`)
    }

    const updated: Post = {
      ...existing,
      ...data,
      updatedAt: new Date()
    }

    // 验证数据
    const validated = this.schema.parse(updated)

    // 更新数据库
    await context.storage.update('posts', { id }, validated)

    // 触发事件
    context.events.emit('post.updated', validated)

    return validated
  },

  async delete(id) {
    await context.storage.delete('posts', { id })
    context.events.emit('post.deleted', { id })
  },

  async query(filter = {}) {
    const { where, orderBy, limit, offset } = filter

    let query = context.storage.query('posts')

    if (where) {
      query = query.where(where)
    }

    if (orderBy) {
      query = query.orderBy(orderBy.field, orderBy.direction)
    }

    if (limit) {
      query = query.limit(limit)
    }

    if (offset) {
      query = query.offset(offset)
    }

    const results = await query.execute()
    return results.map(r => this.schema.parse(r))
  },

  async findById(id) {
    const result = await context.storage.findOne('posts', { id })
    return result ? this.schema.parse(result) : null
  },

  // 数据迁移
  migrations: [
    {
      version: 1,
      async up(db) {
        await db.createTable('posts', {
          id: 'TEXT PRIMARY KEY',
          title: 'TEXT NOT NULL',
          content: 'TEXT',
          status: 'TEXT NOT NULL',
          createdAt: 'INTEGER NOT NULL',
          updatedAt: 'INTEGER NOT NULL'
        })
      },
      async down(db) {
        await db.dropTable('posts')
      }
    },
    {
      version: 2,
      async up(db) {
        await db.addColumn('posts', 'platforms', 'TEXT')
        await db.addColumn('posts', 'scheduledAt', 'INTEGER')
        await db.addColumn('posts', 'publishedAt', 'INTEGER')
      },
      async down(db) {
        await db.dropColumn('posts', 'platforms')
        await db.dropColumn('posts', 'scheduledAt')
        await db.dropColumn('posts', 'publishedAt')
      }
    }
  ]
})
```

## 集成插件

### 接口定义

```typescript
interface IntegrationPlugin extends Plugin {
  type: 'integration'

  // 认证
  auth(credentials: any): Promise<AuthResult>
  refreshAuth?(): Promise<AuthResult>
  logout?(): Promise<void>

  // 配置 schema
  configSchema: z.ZodSchema

  // 能力接口（由具体集成定义）
  [key: string]: any
}

// 认证结果
interface AuthResult {
  success: boolean
  accessToken?: string
  refreshToken?: string
  expiresAt?: Date
  error?: string
}
```

### 实现示例：小红书集成

```typescript
// plugins/xiaohongshu-integration/src/index.ts
import { defineIntegrationPlugin } from '@creatorflow/plugin-sdk'
import { z } from 'zod'

const XiaohongshuConfigSchema = z.object({
  apiKey: z.string(),
  apiSecret: z.string(),
  redirectUri: z.string()
})

export default defineIntegrationPlugin({
  id: 'integration.xiaohongshu',
  name: '小红书集成',
  version: '1.0.0',
  configSchema: XiaohongshuConfigSchema,

  async onLoad(context) {
    // 加载配置
    this.config = await context.storage.get('xiaohongshu.config')

    // 初始化 API 客户端
    this.client = new XiaohongshuClient(this.config)
  },

  // 认证
  async auth(credentials: { code: string }) {
    try {
      const response = await this.client.oauth.getAccessToken({
        code: credentials.code,
        clientId: this.config.apiKey,
        clientSecret: this.config.apiSecret,
        redirectUri: this.config.redirectUri
      })

      // 保存 token
      await context.storage.set('xiaohongshu.token', {
        accessToken: response.access_token,
        refreshToken: response.refresh_token,
        expiresAt: new Date(Date.now() + response.expires_in * 1000)
      })

      return {
        success: true,
        accessToken: response.access_token,
        refreshToken: response.refresh_token,
        expiresAt: new Date(Date.now() + response.expires_in * 1000)
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  },

  // 刷新 token
  async refreshAuth() {
    const token = await context.storage.get('xiaohongshu.token')

    const response = await this.client.oauth.refreshAccessToken({
      refreshToken: token.refreshToken,
      clientId: this.config.apiKey,
      clientSecret: this.config.apiSecret
    })

    await context.storage.set('xiaohongshu.token', {
      accessToken: response.access_token,
      refreshToken: response.refresh_token,
      expiresAt: new Date(Date.now() + response.expires_in * 1000)
    })

    return {
      success: true,
      accessToken: response.access_token,
      refreshToken: response.refresh_token,
      expiresAt: new Date(Date.now() + response.expires_in * 1000)
    }
  },

  // 发布作品
  async publish(post: {
    title: string
    content: string
    images: string[]
    tags?: string[]
  }) {
    const token = await this.getValidToken()

    // 上传图片
    const imageIds = await Promise.all(
      post.images.map(img => this.uploadImage(img, token))
    )

    // 创建笔记
    const response = await this.client.notes.create({
      title: post.title,
      content: post.content,
      imageIds,
      tags: post.tags
    }, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    return {
      id: response.note_id,
      url: `https://www.xiaohongshu.com/explore/${response.note_id}`,
      publishedAt: new Date()
    }
  },

  // 获取数据
  async fetchData(query: {
    startDate?: Date
    endDate?: Date
    noteIds?: string[]
  }) {
    const token = await this.getValidToken()

    const response = await this.client.analytics.getNoteStats({
      startDate: query.startDate?.toISOString(),
      endDate: query.endDate?.toISOString(),
      noteIds: query.noteIds
    }, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    return response.data.map(item => ({
      noteId: item.note_id,
      views: item.views,
      likes: item.likes,
      comments: item.comments,
      shares: item.shares,
      collects: item.collects
    }))
  },

  // 获取有效 token
  async getValidToken() {
    const token = await context.storage.get('xiaohongshu.token')

    // 检查是否过期
    if (new Date() >= token.expiresAt) {
      const refreshed = await this.refreshAuth()
      return refreshed.accessToken
    }

    return token.accessToken
  },

  // 上传图片
  async uploadImage(imagePath: string, token: string) {
    const imageData = await fs.readFile(imagePath)

    const response = await this.client.media.upload({
      file: imageData,
      type: 'image'
    }, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    return response.media_id
  },

  // 配置界面
  getSettingsUI() {
    return XiaohongshuSettings
  }
})
```

### 配置界面

```typescript
// plugins/xiaohongshu-integration/src/settings.tsx
import React, { useState } from 'react'
import { usePluginContext } from '@creatorflow/plugin-sdk'

export default function XiaohongshuSettings() {
  const context = usePluginContext()
  const [config, setConfig] = useState({
    apiKey: '',
    apiSecret: '',
    redirectUri: ''
  })

  const handleSave = async () => {
    await context.storage.set('xiaohongshu.config', config)
    context.logger.info('Configuration saved')
  }

  const handleAuth = () => {
    const plugin = context.registry.get('integration.xiaohongshu')
    const authUrl = plugin.getAuthUrl()
    window.open(authUrl, '_blank')
  }

  return (
    <div className="settings-panel">
      <h2>小红书集成配置</h2>

      <div className="form-group">
        <label>API Key</label>
        <input
          type="text"
          value={config.apiKey}
          onChange={e => setConfig({ ...config, apiKey: e.target.value })}
        />
      </div>

      <div className="form-group">
        <label>API Secret</label>
        <input
          type="password"
          value={config.apiSecret}
          onChange={e => setConfig({ ...config, apiSecret: e.target.value })}
        />
      </div>

      <div className="form-group">
        <label>Redirect URI</label>
        <input
          type="text"
          value={config.redirectUri}
          onChange={e => setConfig({ ...config, redirectUri: e.target.value })}
        />
      </div>

      <button onClick={handleSave}>保存配置</button>
      <button onClick={handleAuth}>授权账号</button>
    </div>
  )
}
```

## 插件开发 SDK

### 定义辅助函数

```typescript
// @creatorflow/plugin-sdk

export function defineUIPlugin(config: UIPluginConfig): UIPlugin {
  return {
    type: 'ui',
    ...config
  }
}

export function defineModelPlugin<T>(config: ModelPluginConfig<T>): ModelPlugin<T> {
  return {
    type: 'model',
    ...config
  }
}

export function defineIntegrationPlugin(config: IntegrationPluginConfig): IntegrationPlugin {
  return {
    type: 'integration',
    ...config
  }
}
```

### React Hooks

```typescript
// 获取插件上下文
export function usePluginContext(): PluginContext {
  return useContext(PluginContextContext)
}

// 获取插件
export function usePlugin<T extends Plugin>(id: string): T | undefined {
  const context = usePluginContext()
  return context.registry.get<T>(id)
}

// 订阅事件
export function usePluginEvent(event: string, handler: (data: any) => void) {
  const context = usePluginContext()

  useEffect(() => {
    context.events.on(event, handler)
    return () => context.events.off(event, handler)
  }, [event, handler])
}
```

## 插件生命周期

### 安装流程

```
1. 下载插件包
2. 验证签名和权限
3. 解压到插件目录
4. 调用 onInstall() 钩子
5. 注册到插件注册表
6. 标记为已安装
```

### 加载流程

```
1. 读取插件 manifest
2. 检查依赖是否满足
3. 动态导入插件代码
4. 调用 onLoad() 钩子
5. 注册路由、菜单等
6. 标记为已加载
```

### 卸载流程

```
1. 调用 onUnload() 钩子
2. 清理路由、菜单等
3. 从注册表移除
4. 调用 onUninstall() 钩子
5. 删除插件文件
6. 清理数据（可选）
```

## 下一步

阅读 [能力层设计](./03_能力层设计.md) 了解 Skills 和 Workflows 的实现。
