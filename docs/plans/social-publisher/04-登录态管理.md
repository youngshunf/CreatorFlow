# 登录态管理与 Playwright 集成

## 登录态管理器

```typescript
// packages/shared/src/social-publisher/session-manager.ts

import { BrowserContext, chromium } from 'playwright';
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

class SocialSessionManager {
  private storageDir: string;  // ~/.creator-flow/social-sessions/
  private encryptionKey: Buffer;

  constructor(baseDir: string, encryptionKey: Buffer) {
    this.storageDir = `${baseDir}/social-sessions`;
    this.encryptionKey = encryptionKey;
  }

  // ========== 登录态存储 ==========

  /**
   * 保存登录态
   * 使用 Playwright 的 storageState 保存完整的浏览器状态
   */
  async saveSession(account: SocialAccount, context: BrowserContext): Promise<void> {
    // 获取完整的浏览器状态（cookies + localStorage + sessionStorage）
    const state = await context.storageState();
    const stateJson = JSON.stringify(state);

    // AES-256-GCM 加密
    const encrypted = this.encrypt(stateJson);

    // 写入文件
    const sessionPath = this.getSessionPath(account.id);
    await fs.mkdir(path.dirname(sessionPath), { recursive: true });
    await fs.writeFile(sessionPath, encrypted, { mode: 0o600 });

    console.log(`[SessionManager] 已保存 ${account.platform} 账号 ${account.nickname} 的登录态`);
  }

  /**
   * 加载登录态
   */
  async loadSession(accountId: string): Promise<StorageState | null> {
    const sessionPath = this.getSessionPath(accountId);

    try {
      const encrypted = await fs.readFile(sessionPath);
      const decrypted = this.decrypt(encrypted);
      return JSON.parse(decrypted);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return null;  // 文件不存在
      }
      throw error;
    }
  }

  /**
   * 删除登录态
   */
  async deleteSession(accountId: string): Promise<void> {
    const sessionPath = this.getSessionPath(accountId);
    try {
      await fs.unlink(sessionPath);
    } catch (error) {
      if (error.code !== 'ENOENT') throw error;
    }
  }

  /**
   * 创建带登录态的浏览器上下文
   */
  async createContext(
    browser: Browser,
    account: SocialAccount
  ): Promise<BrowserContext> {
    const storageState = await this.loadSession(account.id);

    const context = await browser.newContext({
      storageState: storageState || undefined,
      viewport: { width: 1280, height: 800 },
      userAgent: this.getRandomUserAgent(),
      locale: 'zh-CN',
      timezoneId: 'Asia/Shanghai',
      // 反检测设置
      bypassCSP: true,
      ignoreHTTPSErrors: true,
    });

    // 注入反检测脚本
    await this.injectAntiDetection(context);

    return context;
  }

  // ========== 加密方法 ==========

  private encrypt(plaintext: string): Buffer {
    const iv = randomBytes(12);
    const cipher = createCipheriv('aes-256-gcm', this.encryptionKey, iv);

    const encrypted = Buffer.concat([
      cipher.update(plaintext, 'utf8'),
      cipher.final()
    ]);
    const authTag = cipher.getAuthTag();

    // 格式: IV (12) + AuthTag (16) + Ciphertext
    return Buffer.concat([iv, authTag, encrypted]);
  }

  private decrypt(data: Buffer): string {
    const iv = data.subarray(0, 12);
    const authTag = data.subarray(12, 28);
    const ciphertext = data.subarray(28);

    const decipher = createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
    decipher.setAuthTag(authTag);

    return Buffer.concat([
      decipher.update(ciphertext),
      decipher.final()
    ]).toString('utf8');
  }

  // ========== 辅助方法 ==========

  private getSessionPath(accountId: string): string {
    return `${this.storageDir}/${accountId}.session.enc`;
  }

  private getRandomUserAgent(): string {
    const userAgents = [
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
    ];
    return userAgents[Math.floor(Math.random() * userAgents.length)];
  }

  /**
   * 注入反检测脚本
   * 隐藏 Playwright 自动化特征
   */
  private async injectAntiDetection(context: BrowserContext): Promise<void> {
    await context.addInitScript(() => {
      // 隐藏 webdriver 标志
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });

      // 修改 plugins 数组
      Object.defineProperty(navigator, 'plugins', {
        get: () => [1, 2, 3, 4, 5],
      });

      // 修改 languages
      Object.defineProperty(navigator, 'languages', {
        get: () => ['zh-CN', 'zh', 'en'],
      });

      // 隐藏自动化相关的 Chrome 属性
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters: any) =>
        parameters.name === 'notifications'
          ? Promise.resolve({ state: Notification.permission } as PermissionStatus)
          : originalQuery(parameters);

      // 修改 Chrome 对象
      (window as any).chrome = {
        runtime: {},
        loadTimes: () => {},
        csi: () => {},
        app: {},
      };
    });
  }
}
```

## 浏览器管理器

```typescript
// packages/shared/src/social-publisher/browser-manager.ts

import { Browser, chromium, Page } from 'playwright';

class BrowserManager {
  private browser: Browser | null = null;
  private sessionManager: SocialSessionManager;

  constructor(sessionManager: SocialSessionManager) {
    this.sessionManager = sessionManager;
  }

  /**
   * 获取或创建浏览器实例
   */
  async getBrowser(): Promise<Browser> {
    if (!this.browser || !this.browser.isConnected()) {
      this.browser = await chromium.launch({
        headless: false,  // 登录时需要显示窗口
        args: [
          '--disable-blink-features=AutomationControlled',
          '--disable-features=IsolateOrigins,site-per-process',
          '--disable-web-security',
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-gpu',
          '--window-size=1280,800',
        ],
      });

      // 监听浏览器关闭事件
      this.browser.on('disconnected', () => {
        this.browser = null;
      });
    }

    return this.browser;
  }

  /**
   * 关闭浏览器
   */
  async closeBrowser(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  /**
   * 执行登录流程
   */
  async performLogin(
    platform: SocialPlatform,
    options: LoginOptions
  ): Promise<LoginResult> {
    const browser = await this.getBrowser();
    const adapter = this.getAdapter(platform);

    // 创建新的浏览器上下文（无登录态）
    const context = await browser.newContext({
      viewport: { width: 1280, height: 800 },
      locale: 'zh-CN',
      timezoneId: 'Asia/Shanghai',
    });

    const page = await context.newPage();

    try {
      options.onProgress?.('正在打开登录页面...');

      // 导航到登录页
      await page.goto(adapter.loginUrl, { waitUntil: 'networkidle' });

      options.onProgress?.('请在浏览器窗口中完成登录...');

      // 等待用户完成登录
      const result = await adapter.waitForLogin(page, options);

      if (result.success && result.account) {
        options.onProgress?.('登录成功，正在保存登录态...');

        // 保存登录态
        await this.sessionManager.saveSession(result.account, context);

        options.onProgress?.('登录态已保存');
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    } finally {
      await context.close();
    }
  }

  /**
   * 检查登录状态
   */
  async checkLoginStatus(account: SocialAccount): Promise<boolean> {
    const browser = await this.getBrowser();
    const adapter = this.getAdapter(account.platform);

    const context = await this.sessionManager.createContext(browser, account);
    const page = await context.newPage();

    try {
      // 访问创作者中心
      await page.goto(adapter.creatorUrl, { waitUntil: 'networkidle' });

      // 检查是否被重定向到登录页
      const currentUrl = page.url();
      const isLoggedIn = !currentUrl.includes('login') &&
                         !currentUrl.includes('signin');

      return isLoggedIn;
    } finally {
      await context.close();
    }
  }

  /**
   * 获取平台适配器
   */
  private getAdapter(platform: SocialPlatform): PlatformAdapter {
    const adapters: Record<SocialPlatform, PlatformAdapter> = {
      xiaohongshu: new XiaohongshuAdapter(this, this.sessionManager),
      douyin: new DouyinAdapter(this, this.sessionManager),
      wechat_mp: new WechatMpAdapter(this, this.sessionManager),
      bilibili: new BilibiliAdapter(this, this.sessionManager),
      kuaishou: new KuaishouAdapter(this, this.sessionManager),
      weibo: new WeiboAdapter(this, this.sessionManager),
      zhihu: new ZhihuAdapter(this, this.sessionManager),
    };

    return adapters[platform];
  }
}
```

## 登录态有效期管理

```typescript
// packages/shared/src/social-publisher/session-checker.ts

class SessionChecker {
  private browserManager: BrowserManager;
  private accountManager: AccountManager;
  private checkInterval: NodeJS.Timer | null = null;

  constructor(browserManager: BrowserManager, accountManager: AccountManager) {
    this.browserManager = browserManager;
    this.accountManager = accountManager;
  }

  /**
   * 启动定期检查
   * 每小时检查一次所有账号的登录状态
   */
  startPeriodicCheck(intervalMs = 3600000): void {
    if (this.checkInterval) return;

    this.checkInterval = setInterval(async () => {
      await this.checkAllAccounts();
    }, intervalMs);

    // 立即执行一次
    this.checkAllAccounts();
  }

  /**
   * 停止定期检查
   */
  stopPeriodicCheck(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }

  /**
   * 检查所有账号
   */
  async checkAllAccounts(): Promise<void> {
    const accounts = await this.accountManager.listAccounts();

    for (const account of accounts) {
      if (account.status === 'banned') continue;

      try {
        const isValid = await this.browserManager.checkLoginStatus(account);

        if (!isValid && account.status === 'active') {
          // 登录态已过期
          await this.accountManager.updateAccount(account.id, {
            status: 'expired',
          });

          // 发送通知
          this.notifyExpired(account);
        } else if (isValid && account.status === 'expired') {
          // 登录态恢复有效（可能用户手动登录了）
          await this.accountManager.updateAccount(account.id, {
            status: 'active',
            lastLoginAt: Date.now(),
          });
        }
      } catch (error) {
        console.error(`检查账号 ${account.nickname} 状态失败:`, error);
      }
    }
  }

  /**
   * 通知用户登录态过期
   */
  private notifyExpired(account: SocialAccount): void {
    // 通过 Electron IPC 发送通知
    if (typeof window !== 'undefined') {
      window.electronAPI?.showNotification({
        title: '登录态过期',
        body: `${account.platform} 账号 "${account.nickname}" 的登录态已过期，请重新登录`,
      });
    }
  }
}
```

## 反检测措施详解

### 1. 浏览器指纹伪装

```typescript
// 完整的反检测脚本
const antiDetectionScript = `
  // 1. 隐藏 webdriver 标志
  Object.defineProperty(navigator, 'webdriver', {
    get: () => undefined,
  });

  // 2. 伪造 plugins
  Object.defineProperty(navigator, 'plugins', {
    get: () => {
      const plugins = [
        { name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer' },
        { name: 'Chrome PDF Viewer', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai' },
        { name: 'Native Client', filename: 'internal-nacl-plugin' },
      ];
      plugins.length = 3;
      return plugins;
    },
  });

  // 3. 伪造 mimeTypes
  Object.defineProperty(navigator, 'mimeTypes', {
    get: () => {
      const mimeTypes = [
        { type: 'application/pdf', suffixes: 'pdf' },
        { type: 'application/x-google-chrome-pdf', suffixes: 'pdf' },
      ];
      mimeTypes.length = 2;
      return mimeTypes;
    },
  });

  // 4. 修改 permissions API
  const originalQuery = window.navigator.permissions.query;
  window.navigator.permissions.query = (parameters) => {
    if (parameters.name === 'notifications') {
      return Promise.resolve({ state: Notification.permission });
    }
    return originalQuery(parameters);
  };

  // 5. 伪造 Chrome 对象
  window.chrome = {
    runtime: {
      connect: () => {},
      sendMessage: () => {},
    },
    loadTimes: () => ({
      commitLoadTime: Date.now() / 1000,
      connectionInfo: 'http/1.1',
      finishDocumentLoadTime: Date.now() / 1000,
      finishLoadTime: Date.now() / 1000,
      firstPaintAfterLoadTime: 0,
      firstPaintTime: Date.now() / 1000,
      navigationType: 'Other',
      npnNegotiatedProtocol: 'http/1.1',
      requestTime: Date.now() / 1000,
      startLoadTime: Date.now() / 1000,
      wasAlternateProtocolAvailable: false,
      wasFetchedViaSpdy: false,
      wasNpnNegotiated: false,
    }),
    csi: () => ({
      onloadT: Date.now(),
      pageT: Date.now(),
      startE: Date.now(),
      tran: 15,
    }),
    app: {
      isInstalled: false,
      InstallState: { DISABLED: 'disabled', INSTALLED: 'installed', NOT_INSTALLED: 'not_installed' },
      RunningState: { CANNOT_RUN: 'cannot_run', READY_TO_RUN: 'ready_to_run', RUNNING: 'running' },
    },
  };

  // 6. 修改 WebGL 渲染器信息
  const getParameter = WebGLRenderingContext.prototype.getParameter;
  WebGLRenderingContext.prototype.getParameter = function(parameter) {
    if (parameter === 37445) {
      return 'Intel Inc.';
    }
    if (parameter === 37446) {
      return 'Intel Iris OpenGL Engine';
    }
    return getParameter.call(this, parameter);
  };

  // 7. 隐藏自动化相关的 window 属性
  delete window.cdc_adoQpoasnfa76pfcZLmcfl_Array;
  delete window.cdc_adoQpoasnfa76pfcZLmcfl_Promise;
  delete window.cdc_adoQpoasnfa76pfcZLmcfl_Symbol;
`;
```

### 2. 人类行为模拟

```typescript
class HumanBehavior {
  /**
   * 模拟人类鼠标移动
   */
  static async humanMouseMove(page: Page, x: number, y: number): Promise<void> {
    const steps = Math.floor(Math.random() * 10) + 5;
    const currentPos = await page.evaluate(() => ({
      x: window.mouseX || 0,
      y: window.mouseY || 0,
    }));

    for (let i = 0; i <= steps; i++) {
      const progress = i / steps;
      // 使用贝塞尔曲线模拟自然移动
      const easeProgress = this.easeInOutQuad(progress);
      const newX = currentPos.x + (x - currentPos.x) * easeProgress;
      const newY = currentPos.y + (y - currentPos.y) * easeProgress;

      await page.mouse.move(newX, newY);
      await this.randomDelay(10, 30);
    }
  }

  /**
   * 模拟人类点击
   */
  static async humanClick(page: Page, selector: string): Promise<void> {
    const element = await page.$(selector);
    if (!element) throw new Error(`Element not found: ${selector}`);

    const box = await element.boundingBox();
    if (!box) throw new Error(`Element not visible: ${selector}`);

    // 随机点击位置（不总是点击中心）
    const x = box.x + box.width * (0.3 + Math.random() * 0.4);
    const y = box.y + box.height * (0.3 + Math.random() * 0.4);

    await this.humanMouseMove(page, x, y);
    await this.randomDelay(50, 150);
    await page.mouse.click(x, y);
  }

  /**
   * 模拟人类输入
   */
  static async humanType(page: Page, selector: string, text: string): Promise<void> {
    await this.humanClick(page, selector);
    await this.randomDelay(100, 300);

    for (const char of text) {
      await page.type(selector, char, {
        delay: 50 + Math.random() * 100,
      });

      // 偶尔暂停一下（模拟思考）
      if (Math.random() < 0.1) {
        await this.randomDelay(200, 500);
      }
    }
  }

  private static easeInOutQuad(t: number): number {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  private static async randomDelay(min: number, max: number): Promise<void> {
    const delay = min + Math.random() * (max - min);
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}
```

## 与现有凭证系统集成

社交账号的登录态存储复用 CreatorFlow 现有的加密机制：

```typescript
// 复用现有的加密密钥派生
import { getCredentialManager } from '@creator-flow/shared/credentials';

async function initSocialSessionManager(): Promise<SocialSessionManager> {
  const credManager = getCredentialManager();

  // 使用相同的加密密钥
  const encryptionKey = await credManager.getEncryptionKey();

  return new SocialSessionManager(
    getCreatorFlowDir(),
    encryptionKey
  );
}
```

这样可以确保：
1. 加密强度一致（AES-256-GCM）
2. 密钥派生方式一致（基于硬件 UUID）
3. 用户体验一致（无需额外配置）
